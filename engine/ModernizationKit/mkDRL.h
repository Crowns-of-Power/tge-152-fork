/*  mkDRL.h
 *  Copyright (C) 2007 Alex Scarborough
 *  For conditions of distribution and use, see copyright notice in ModernizationKit.h
 */

#ifndef _MKDRL_H_
#define _MKDRL_H_

#ifndef _PLATFORM_H_
#include "platform/platform.h"
#endif

class RenderTexture;

/// A handy class which will eventually handle all things pertaining to DRL
class _DRL
{
   private:
   /// Have we initialized?
   bool mInit;
   
   /// If DRL is active
   bool mIsActive;
   /// if 0, no bloom
   /// if 1, we fake bloom.  Same color adjustment, no blur.
   /// if 2, we do a very slight blur.  Just a downsample/upsample
   /// if 3, we actually run through a shader and get an adjustable blur amount
   U32 mBloomQuality;
   
   /// Current scale.  Only used on sub 2.0 cards
   F32 mScale;
   
   /// Current bias.  Only used on sub 2.0 cards
   F32 mConstant;
   
   /// Our desired average intensity
   F32 mGoalIntensity;
   
   /// How quickly the scale can change per second
   F32 mScaleChangeRate;
   
   /// How quickly the bias can change per second
   F32 mBiasChangeRate;
   
   /// The current average intensity of the scene.  Only used on sub 2.0 cards
   F32 mAverageIntensity;
   
   /// A tolerance level for scale/bias changes
   F32 mChangeTolerance;
   
   /// The maximum bias we allow.  Absolute max on 2.0 cards is 0.
   F32 mMaxBias;
   
   /// The maximum scale we allow.  Absolute max on 2.0 cards is 4
   F32 mMaxScale;
   
   /// The smallest bias we allow.  Absolute min on 2.0 cards is -0.25
   F32 mMinBias;
   
   /// The smallest scale we allow.  Absolute min is 0.
   F32 mMinScale;
   
   /// Generally, bloom is generated by subtracting the goal intensity from the scene.  This value is added to the
   /// goal intensity before subtracting it from the scene.
   F32 mBloomColorOffset;
   
   /// The bloom color is multiplied by this before being applied.  Greater numbers = more bloom, smaller
   /// numbers = less bloom.  Default is 1.
   F32 mBloomMultiplier;
   
   /// This increases the radius of the bloom taps.
   F32 mBloomRadius;
   
   /// This is a nifty bool only used on 2.0 cards
   bool mUseSwapInfo;
   
   /// Final composition render texture
   RenderTexture* mFinalRT;
   
   /// First bloom render texture
   RenderTexture* mBloom0RT;
   
   /// Second bloom render texture
   RenderTexture* mBloom1RT;
   
   /// RTs for average intensity cause the Win32 drivers suck and won't let me just mip this.
   RenderTexture* mAvgIntPingPongRTs[10];
   
   U32 mAvgIntPingPongIdx;
   
   /// Info texture
   RenderTexture* mInfo0RT;
   
   /// Info texture
   RenderTexture* mInfo1RT;
   
   /// Initializes our RenderTextures
   void init();
   
   /// Render path for 2.0 cards with true RtT support.
   void render20();
   
   void pingPongAvgInt();
   
   void bindInfoTexture(U32 samplerNum);
   void loadBloomGenShader();
   void loadBlurShader(bool horiz, U32 extentX, U32 extentY, U32 texWidth, U32 texHeight);
   void loadCompositionShader();
   void calcInfoTexture();
   void savePrefs();
   
   _DRL();
   ~_DRL();
   
   public:
   static void create();
   static void destroy();
   
   void setGoalIntensity(F32 intensity);
   void setChangeRates(F32 scaleRate, F32 biasRate);
   void setChangeTolerance(F32 tolerance);
   void setScaleLimits(F32 min, F32 max);
   void setBiasLimits(F32 min, F32 max);
   void setBloomColorOffset(F32 offset);
   void setBloomMultiplier(F32 multiplier);
   void setBloomQuality(U32 quality);
   void setBloomRadius(F32 radius);
   
   /// Are we using DRL?
   void setActive(bool active);
   
   /// Should we use DRL?
   bool isActive() { return mIsActive; }
   
   /// Renders DRL as a full screen effect.
   ///
   /// One day, maybe, it'll allow you to render DRL only for a specified portion of the screen.
   /// For now, that takes work, and I'm lazy (as mentioned numerous times throughout the documentation)
   void render();
};

extern _DRL *DRL;

#endif
   


